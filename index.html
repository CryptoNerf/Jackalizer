<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jackalizer</title>
    <meta property="og:image" content="img/preview.jpg">
    <meta property="og:title" content="Jackalizer">
    <meta property="og:description" content="Image pixelation tool">
    <link rel="icon" type="image/png" href="img/favicon.png">
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <h1 class="main-title">Jackalizer</h1>
    <img class="header-image" src="img/jackalizer2.png" alt="">
    <div class="main-container" id="mainContainer">
        <div class="panel left-panel">
            <div class="drop-zone" id="dropZone">
                <p>your photo</p>
                <input type="file" id="fileInput" accept="image/*">
            </div>
            <canvas id="canvas"></canvas>
        </div>

        <div class="panel right-panel hidden" id="rightPanel">
            <div class="control-group">
                <label>–í—ã–±–µ—Ä–∏—Ç–µ —ç—Ñ—Ñ–µ–∫—Ç:</label>
                <div class="button-group">
                    <button id="pixelEffectBtn" class="mode-btn active">–ü–∏–∫—Å–µ–ª–∏–∑–∞—Ü–∏—è</button>
                    <button id="blurEffectBtn" class="mode-btn">–ë–ª—é—Ä</button>
                    <button id="glitchEffectBtn" class="mode-btn">–ì–ª–∏—Ç—á</button>
                </div>
            </div>

            <div class="control-group" id="pixelControls">
                <label for="pixelSize">–°—Ç–µ–ø–µ–Ω—å –ø–∏–∫—Å–µ–ª–∏–∑–∞—Ü–∏–∏: <span id="pixelSizeValue">62</span></label>
                <input type="range" id="pixelSize" min="2" max="100" value="62">
            </div>

            <div class="control-group hidden" id="blurControls">
                <label for="blurSize">–°–∏–ª–∞ –±–ª—é—Ä–∞: <span id="blurSizeValue">10</span></label>
                <input type="range" id="blurSize" min="1" max="50" value="10">
            </div>

            <div class="control-group hidden" id="glitchControls">
                <label for="glitchIntensity">–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –≥–ª–∏—Ç—á–∞: <span id="glitchIntensityValue">15</span></label>
                <input type="range" id="glitchIntensity" min="1" max="50" value="15">
            </div>

            <div class="control-group hidden" id="brushControls">
                <label>–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è:</label>
                <div class="button-group">
                    <button id="brushBtn" class="mode-btn">üñåÔ∏è –ö–∏—Å—Ç—å</button>
                    <button id="eraserBtn" class="mode-btn">üßπ –õ–∞—Å—Ç–∏–∫</button>
                </div>
                <label for="brushSize">–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏: <span id="brushSizeValue">30</span></label>
                <input type="range" id="brushSize" min="5" max="100" value="30">
                <button id="clearMaskBtn" class="secondary-btn">–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
                <button id="applyFullBtn" class="secondary-btn">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–æ –≤—Å–µ–º—É</button>
            </div>

            <div class="buttons hidden" id="buttons">
                <button id="downloadBtn">–°–∫–∞—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
                <button id="resetBtn">–ù–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</button>
            </div>
        </div>
    </div>

    <footer>
        <a href="https://cryptonerf.github.io/portfolio/" target="_blank">Copyright 2025 √âmile Alexanyan</a>
    </footer>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const mainContainer = document.getElementById('mainContainer');
        const rightPanel = document.getElementById('rightPanel');
        const buttons = document.getElementById('buttons');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const pixelEffectBtn = document.getElementById('pixelEffectBtn');
        const blurEffectBtn = document.getElementById('blurEffectBtn');
        const glitchEffectBtn = document.getElementById('glitchEffectBtn');
        const pixelControls = document.getElementById('pixelControls');
        const blurControls = document.getElementById('blurControls');
        const glitchControls = document.getElementById('glitchControls');
        const pixelSizeSlider = document.getElementById('pixelSize');
        const pixelSizeValue = document.getElementById('pixelSizeValue');
        const blurSizeSlider = document.getElementById('blurSize');
        const blurSizeValue = document.getElementById('blurSizeValue');
        const glitchIntensitySlider = document.getElementById('glitchIntensity');
        const glitchIntensityValue = document.getElementById('glitchIntensityValue');
        const brushControls = document.getElementById('brushControls');
        const brushBtn = document.getElementById('brushBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const brushSizeSlider = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const clearMaskBtn = document.getElementById('clearMaskBtn');
        const applyFullBtn = document.getElementById('applyFullBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');

        let currentImage = null;
        let originalImageData = null;
        let pixelatedImageData = null; // –ö—ç—à –¥–ª—è –ø–∏–∫—Å–µ–ª–∏–∑–∞—Ü–∏–∏
        let blurredImageData = null; // –ö—ç—à –¥–ª—è –±–ª—é—Ä–∞
        let glitchImageData = null; // –ö—ç—à –¥–ª—è –≥–ª–∏—Ç—á–∞
        let isDrawing = false;
        let brushMode = 'brush'; // 'brush' or 'eraser'
        let brushSize = 30;
        let currentEffect = 'pixelate'; // 'pixelate' | 'blur' | 'glitch'
        let scaleRatio = 1; // –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –º–µ–∂–¥—É –æ—Ä–∏–≥–∏–Ω–∞–ª–æ–º –∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã–º —Ä–∞–∑–º–µ—Ä–æ–º

        // –û–ø–µ—Ä–∞—Ü–∏–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏—è (–≤ –ø–æ—Ä—è–¥–∫–µ —Å–æ–∑–¥–∞–Ω–∏—è)
        let operations = []; // [{type: 'pixelate'|'blur'|'glitch', maskCanvas, maskCtx}]
        let lastDrawnEffect = null;

        // Drag & Drop
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadImage(file);
            }
        });

        // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    setupCanvas(img);
                    showControls();
                    renderCanvas();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞–Ω–≤–∞—Å–∞
        function setupCanvas(img) {
            const maxWidth = 800;
            const scale = Math.min(1, maxWidth / img.width);
            const width = Math.floor(img.width * scale);
            const height = Math.floor(img.height * scale);
            scaleRatio = scale;

            canvas.width = width;
            canvas.height = height;

            ctx.drawImage(img, 0, 0, width, height);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            originalImageData = ctx.getImageData(0, 0, width, height);

            // –û—á–∏—â–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏
            operations = [];
            lastDrawnEffect = null;
        }

        // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
        function createOperation(type) {
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = canvas.width;
            maskCanvas.height = canvas.height;
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.fillStyle = 'black';
            maskCtx.fillRect(0, 0, canvas.width, canvas.height);

            const operation = { type, maskCanvas, maskCtx };
            operations.push(operation);
            return operation;
        }

        // –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è
        function getCurrentOperation() {
            // –ï—Å–ª–∏ –Ω–∞—á–∞–ª–∏ —Ä–∏—Å–æ–≤–∞—Ç—å –Ω–æ–≤—ã–º —ç—Ñ—Ñ–µ–∫—Ç–æ–º, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
            if (!operations.length || lastDrawnEffect !== currentEffect) {
                lastDrawnEffect = currentEffect;
                return createOperation(currentEffect);
            }

            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –æ–ø–µ—Ä–∞—Ü–∏—é —Ç–µ–∫—É—â–µ–≥–æ —Ç–∏–ø–∞
            for (let i = operations.length - 1; i >= 0; i--) {
                if (operations[i].type === currentEffect) {
                    return operations[i];
                }
            }

            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é
            return createOperation(currentEffect);
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function showControls() {
            dropZone.classList.add('hidden');
            canvas.style.display = 'block';
            rightPanel.classList.remove('hidden');
            mainContainer.classList.add('two-panels');
            brushControls.classList.remove('hidden');
            buttons.classList.remove('hidden');
        }

        // ============ –†–ï–ù–î–ï–†–ò–ù–ì ============

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (–∫—ç—à)
        function generatePixelatedImage() {
            if (!currentImage || !originalImageData) return null;

            const pixelSize = parseInt(pixelSizeSlider.value);
            const width = canvas.width;
            const height = canvas.height;

            if (pixelSize <= 2) {
                return originalImageData;
            }

            const smallWidth = Math.ceil(width / pixelSize);
            const smallHeight = Math.ceil(height / pixelSize);

            // –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º –∫–∞–Ω–≤–∞—Å —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
            const fullCanvas = document.createElement('canvas');
            const fullCtx = fullCanvas.getContext('2d');
            fullCanvas.width = width;
            fullCanvas.height = height;
            fullCtx.putImageData(originalImageData, 0, 0);

            // –£–º–µ–Ω—å—à–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = smallWidth;
            tempCanvas.height = smallHeight;
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(fullCanvas, 0, 0, width, height, 0, 0, smallWidth, smallHeight);

            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ –¥–ª—è –ø–∏–∫—Å–µ–ª–∏–∑–∞—Ü–∏–∏
            const pixelatedCanvas = document.createElement('canvas');
            const pixelatedCtx = pixelatedCanvas.getContext('2d');
            pixelatedCanvas.width = width;
            pixelatedCanvas.height = height;
            pixelatedCtx.imageSmoothingEnabled = false;
            pixelatedCtx.drawImage(tempCanvas, 0, 0, smallWidth, smallHeight, 0, 0, width, height);

            return pixelatedCtx.getImageData(0, 0, width, height);
        }

        function generateBlurredImage() {
            if (!currentImage || !originalImageData) return null;

            const blurSize = parseInt(blurSizeSlider.value);
            const width = canvas.width;
            const height = canvas.height;

            if (blurSize <= 1) {
                return originalImageData;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempCtx.putImageData(originalImageData, 0, 0);

            const blurredCanvas = document.createElement('canvas');
            const blurredCtx = blurredCanvas.getContext('2d');
            blurredCanvas.width = width;
            blurredCanvas.height = height;
            blurredCtx.filter = `blur(${blurSize}px)`;
            blurredCtx.drawImage(tempCanvas, 0, 0);
            blurredCtx.filter = 'none';

            return blurredCtx.getImageData(0, 0, width, height);
        }

        function generateGlitchImage() {
            if (!currentImage || !originalImageData) return null;

            const intensity = parseInt(glitchIntensitySlider.value);
            const width = canvas.width;
            const height = canvas.height;

            if (intensity <= 0) {
                return originalImageData;
            }

            const result = new ImageData(width, height);
            const original = originalImageData.data;

            // –ö–æ–ø–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –∫–∞–∫ –±–∞–∑—É
            result.data.set(original);

            // RGB —Å–º–µ—â–µ–Ω–∏–µ (—É—Å–∏–ª–µ–Ω–Ω–æ–µ)
            const rgbOffset = Math.floor(intensity / 2);

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –±–ª–æ–∫–∏ –∏—Å–∫–∞–∂–µ–Ω–∏–π
            const numBlocks = Math.floor(intensity / 5);
            const blocks = [];
            for (let i = 0; i < numBlocks; i++) {
                blocks.push({
                    y: Math.floor(Math.random() * height),
                    height: Math.floor(Math.random() * (intensity * 2)) + 5,
                    shift: Math.floor((Math.random() - 0.5) * intensity * 3),
                    type: Math.random()
                });
            }

            // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
            for (let y = 0; y < height; y++) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤ –±–ª–æ–∫ –∏—Å–∫–∞–∂–µ–Ω–∏–π
                let blockShift = 0;
                let blockType = 0;
                for (const block of blocks) {
                    if (y >= block.y && y < block.y + block.height) {
                        blockShift = block.shift;
                        blockType = block.type;
                        break;
                    }
                }

                // –°–ª—É—á–∞–π–Ω—ã–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –≥–ª–∏—Ç—á–∏
                const randomGlitch = Math.random() < (intensity / 150);
                const lineShift = randomGlitch ? Math.floor((Math.random() - 0.5) * intensity * 2) : 0;

                const totalShift = blockShift + lineShift;

                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    // RGB-—Å–º–µ—â–µ–Ω–∏–µ —Å —É—á–µ—Ç–æ–º —Å–¥–≤–∏–≥–∞ –±–ª–æ–∫–∞
                    const xR = Math.min(Math.max(x + rgbOffset + totalShift, 0), width - 1);
                    const iR = (y * width + xR) * 4;

                    const xG = Math.min(Math.max(x + totalShift, 0), width - 1);
                    const iG = (y * width + xG) * 4;

                    const xB = Math.min(Math.max(x - rgbOffset + totalShift, 0), width - 1);
                    const iB = (y * width + xB) * 4;

                    result.data[i] = original[iR];
                    result.data[i + 1] = original[iG + 1];
                    result.data[i + 2] = original[iB + 2];

                    // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ –±–ª–æ–∫–∞—Ö
                    if (blockShift !== 0) {
                        if (blockType < 0.3) {
                            // –ò–Ω–≤–µ—Ä—Å–∏—è —Ü–≤–µ—Ç–æ–≤
                            result.data[i] = 255 - result.data[i];
                            result.data[i + 1] = 255 - result.data[i + 1];
                            result.data[i + 2] = 255 - result.data[i + 2];
                        } else if (blockType < 0.5) {
                            // –£—Å–∏–ª–µ–Ω–∏–µ –∫—Ä–∞—Å–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
                            result.data[i] = Math.min(result.data[i] * 1.5, 255);
                        } else if (blockType < 0.7) {
                            // –£—Å–∏–ª–µ–Ω–∏–µ —Å–∏–Ω–µ–≥–æ/–∑–µ–ª–µ–Ω–æ–≥–æ (cyan)
                            result.data[i + 1] = Math.min(result.data[i + 1] * 1.3, 255);
                            result.data[i + 2] = Math.min(result.data[i + 2] * 1.3, 255);
                        }
                    }

                    // –°–ª—É—á–∞–π–Ω—ã–π —à—É–º –≤ –≥–ª–∏—Ç—á-–ª–∏–Ω–∏—è—Ö
                    if (randomGlitch && Math.random() < 0.1) {
                        const noise = Math.floor((Math.random() - 0.5) * 100);
                        result.data[i] = Math.max(0, Math.min(255, result.data[i] + noise));
                        result.data[i + 1] = Math.max(0, Math.min(255, result.data[i + 1] + noise));
                        result.data[i + 2] = Math.max(0, Math.min(255, result.data[i + 2] + noise));
                    }
                }
            }

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å—ã –∏—Å–∫–∞–∂–µ–Ω–∏–π
            const numStripes = Math.floor(intensity / 8);
            for (let i = 0; i < numStripes; i++) {
                const stripeX = Math.floor(Math.random() * width);
                const stripeWidth = Math.floor(Math.random() * 5) + 1;
                const stripeShift = Math.floor((Math.random() - 0.5) * intensity);

                for (let y = 0; y < height; y++) {
                    for (let dx = 0; dx < stripeWidth; dx++) {
                        const x = stripeX + dx;
                        if (x >= 0 && x < width) {
                            const sourceY = Math.min(Math.max(y + stripeShift, 0), height - 1);
                            const i = (y * width + x) * 4;
                            const iSource = (sourceY * width + x) * 4;

                            result.data[i] = original[iSource];
                            result.data[i + 1] = original[iSource + 1];
                            result.data[i + 2] = original[iSource + 2];
                        }
                    }
                }
            }

            return result;
        }

        // –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
        function renderCanvas() {
            if (!originalImageData) return;

            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
            pixelatedImageData = generatePixelatedImage();
            blurredImageData = generateBlurredImage();
            glitchImageData = generateGlitchImage();

            const width = canvas.width;
            const height = canvas.height;

            // –ù–∞—á–∏–Ω–∞–µ–º —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–∞
            let result = ctx.createImageData(width, height);
            result.data.set(originalImageData.data);

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö —Å–æ–∑–¥–∞–Ω–∏—è
            operations.forEach(operation => {
                let effectData;
                if (operation.type === 'pixelate') {
                    effectData = pixelatedImageData;
                } else if (operation.type === 'blur') {
                    effectData = blurredImageData;
                } else if (operation.type === 'glitch') {
                    effectData = glitchImageData;
                }

                if (!effectData) return;

                const maskData = operation.maskCtx.getImageData(0, 0, width, height).data;

                for (let i = 0; i < result.data.length; i += 4) {
                    const maskValue = maskData[i] / 255;
                    result.data[i] = result.data[i] * (1 - maskValue) + effectData.data[i] * maskValue;
                    result.data[i + 1] = result.data[i + 1] * (1 - maskValue) + effectData.data[i + 1] * maskValue;
                    result.data[i + 2] = result.data[i + 2] * (1 - maskValue) + effectData.data[i + 2] * maskValue;
                }
            });

            ctx.putImageData(result, 0, 0);
        }

        // –†–∏—Å–æ–≤–∞–Ω–∏–µ –º–∞—Å–∫–∏
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function drawOnMask(x, y) {
            if (brushMode === 'brush') {
                // –†–∏—Å—É–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞ –º–∞—Å–∫–µ —Ç–µ–∫—É—â–µ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
                const operation = getCurrentOperation();
                if (!operation) return;

                operation.maskCtx.fillStyle = 'white';
                operation.maskCtx.beginPath();
                operation.maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
                operation.maskCtx.fill();
            } else {
                // –õ–∞—Å—Ç–∏–∫ —Å—Ç–∏—Ä–∞–µ—Ç —Å–æ –≤—Å–µ—Ö –º–∞—Å–æ–∫ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
                operations.forEach(op => {
                    op.maskCtx.fillStyle = 'black';
                    op.maskCtx.beginPath();
                    op.maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
                    op.maskCtx.fill();
                });
            }

            renderCanvas();
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!currentImage) return;
            isDrawing = true;
            const coords = getCanvasCoordinates(e);
            drawOnMask(coords.x, coords.y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || !currentImage) return;
            const coords = getCanvasCoordinates(e);
            drawOnMask(coords.x, coords.y);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch events –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
        canvas.addEventListener('touchstart', (e) => {
            if (!currentImage) return;
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            const coords = getCanvasCoordinates(touch);
            drawOnMask(coords.x, coords.y);
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDrawing || !currentImage) return;
            e.preventDefault();
            const touch = e.touches[0];
            const coords = getCanvasCoordinates(touch);
            drawOnMask(coords.x, coords.y);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∏—Å—Ç—å—é
        brushBtn.addEventListener('click', () => {
            brushMode = 'brush';
            brushBtn.classList.add('active');
            eraserBtn.classList.remove('active');
        });

        eraserBtn.addEventListener('click', () => {
            brushMode = 'eraser';
            eraserBtn.classList.add('active');
            brushBtn.classList.remove('active');
        });

        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeValue.textContent = brushSize;
        });

        clearMaskBtn.addEventListener('click', () => {
            // –û—á–∏—â–∞–µ–º –≤—Å–µ –º–∞—Å–∫–∏
            operations.forEach(op => {
                op.maskCtx.fillStyle = 'black';
                op.maskCtx.fillRect(0, 0, canvas.width, canvas.height);
            });
            renderCanvas();
        });

        applyFullBtn.addEventListener('click', () => {
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —ç—Ñ—Ñ–µ–∫—Ç –∫–æ –≤—Å–µ–º—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
            const operation = getCurrentOperation();
            if (!operation) return;

            operation.maskCtx.fillStyle = 'white';
            operation.maskCtx.fillRect(0, 0, canvas.width, canvas.height);
            renderCanvas();
        });

        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        pixelEffectBtn.addEventListener('click', () => {
            currentEffect = 'pixelate';
            pixelEffectBtn.classList.add('active');
            blurEffectBtn.classList.remove('active');
            glitchEffectBtn.classList.remove('active');
            pixelControls.classList.remove('hidden');
            blurControls.classList.add('hidden');
            glitchControls.classList.add('hidden');
        });

        blurEffectBtn.addEventListener('click', () => {
            currentEffect = 'blur';
            blurEffectBtn.classList.add('active');
            pixelEffectBtn.classList.remove('active');
            glitchEffectBtn.classList.remove('active');
            blurControls.classList.remove('hidden');
            pixelControls.classList.add('hidden');
            glitchControls.classList.add('hidden');
        });

        glitchEffectBtn.addEventListener('click', () => {
            currentEffect = 'glitch';
            glitchEffectBtn.classList.add('active');
            pixelEffectBtn.classList.remove('active');
            blurEffectBtn.classList.remove('active');
            glitchControls.classList.remove('hidden');
            pixelControls.classList.add('hidden');
            blurControls.classList.add('hidden');
        });

        // –°–ª—É—à–∞—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        pixelSizeSlider.addEventListener('input', (e) => {
            pixelSizeValue.textContent = e.target.value;
            renderCanvas();
        });

        blurSizeSlider.addEventListener('input', (e) => {
            blurSizeValue.textContent = e.target.value;
            renderCanvas();
        });

        glitchIntensitySlider.addEventListener('input', (e) => {
            glitchIntensityValue.textContent = e.target.value;
            renderCanvas();
        });

        // –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º —Ä–∞–∑–º–µ—Ä–µ
        downloadBtn.addEventListener('click', () => {
            if (!currentImage) return;

            const originalWidth = currentImage.width;
            const originalHeight = currentImage.height;

            // –°–æ–∑–¥–∞—ë–º —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ –ø–æ–ª–Ω–æ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏
            const pixelSize = parseInt(pixelSizeSlider.value);
            const scaledPixelSize = pixelSize / scaleRatio;
            const smallWidth = Math.ceil(originalWidth / scaledPixelSize);
            const smallHeight = Math.ceil(originalHeight / scaledPixelSize);

            const tempCanvas1 = document.createElement('canvas');
            const tempCtx1 = tempCanvas1.getContext('2d');
            tempCanvas1.width = smallWidth;
            tempCanvas1.height = smallHeight;
            tempCtx1.imageSmoothingEnabled = true;
            tempCtx1.drawImage(currentImage, 0, 0, originalWidth, originalHeight, 0, 0, smallWidth, smallHeight);

            const fullPixelatedCanvas = document.createElement('canvas');
            const fullPixelatedCtx = fullPixelatedCanvas.getContext('2d');
            fullPixelatedCanvas.width = originalWidth;
            fullPixelatedCanvas.height = originalHeight;
            fullPixelatedCtx.imageSmoothingEnabled = false;
            fullPixelatedCtx.drawImage(tempCanvas1, 0, 0, smallWidth, smallHeight, 0, 0, originalWidth, originalHeight);
            const fullPixelatedData = fullPixelatedCtx.getImageData(0, 0, originalWidth, originalHeight);

            const blurSize = parseInt(blurSizeSlider.value);
            const scaledBlurSize = blurSize / scaleRatio;

            const tempCanvas2 = document.createElement('canvas');
            const tempCtx2 = tempCanvas2.getContext('2d');
            tempCanvas2.width = originalWidth;
            tempCanvas2.height = originalHeight;
            tempCtx2.drawImage(currentImage, 0, 0, originalWidth, originalHeight);

            const fullBlurredCanvas = document.createElement('canvas');
            const fullBlurredCtx = fullBlurredCanvas.getContext('2d');
            fullBlurredCanvas.width = originalWidth;
            fullBlurredCanvas.height = originalHeight;
            fullBlurredCtx.filter = `blur(${scaledBlurSize}px)`;
            fullBlurredCtx.drawImage(tempCanvas2, 0, 0);
            fullBlurredCtx.filter = 'none';
            const fullBlurredData = fullBlurredCtx.getImageData(0, 0, originalWidth, originalHeight);

            // –°–æ–∑–¥–∞—ë–º –≥–ª–∏—Ç—á-—ç—Ñ—Ñ–µ–∫—Ç –≤ –ø–æ–ª–Ω–æ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏
            const glitchIntensity = parseInt(glitchIntensitySlider.value);
            const scaledGlitchIntensity = Math.max(1, Math.floor(glitchIntensity / scaleRatio));

            const tempCanvas3 = document.createElement('canvas');
            const tempCtx3 = tempCanvas3.getContext('2d');
            tempCanvas3.width = originalWidth;
            tempCanvas3.height = originalHeight;
            tempCtx3.drawImage(currentImage, 0, 0, originalWidth, originalHeight);
            const fullOriginalData = tempCtx3.getImageData(0, 0, originalWidth, originalHeight);

            const fullGlitchData = new ImageData(originalWidth, originalHeight);
            fullGlitchData.data.set(fullOriginalData.data);

            const rgbOffset = Math.floor(scaledGlitchIntensity / 2);

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –±–ª–æ–∫–∏
            const numBlocks = Math.floor(scaledGlitchIntensity / 5);
            const blocks = [];
            for (let i = 0; i < numBlocks; i++) {
                blocks.push({
                    y: Math.floor(Math.random() * originalHeight),
                    height: Math.floor(Math.random() * (scaledGlitchIntensity * 2)) + 5,
                    shift: Math.floor((Math.random() - 0.5) * scaledGlitchIntensity * 3),
                    type: Math.random()
                });
            }

            for (let y = 0; y < originalHeight; y++) {
                let blockShift = 0;
                let blockType = 0;
                for (const block of blocks) {
                    if (y >= block.y && y < block.y + block.height) {
                        blockShift = block.shift;
                        blockType = block.type;
                        break;
                    }
                }

                const randomGlitch = Math.random() < (scaledGlitchIntensity / 150);
                const lineShift = randomGlitch ? Math.floor((Math.random() - 0.5) * scaledGlitchIntensity * 2) : 0;
                const totalShift = blockShift + lineShift;

                for (let x = 0; x < originalWidth; x++) {
                    const i = (y * originalWidth + x) * 4;

                    const xR = Math.min(Math.max(x + rgbOffset + totalShift, 0), originalWidth - 1);
                    const iR = (y * originalWidth + xR) * 4;
                    const xG = Math.min(Math.max(x + totalShift, 0), originalWidth - 1);
                    const iG = (y * originalWidth + xG) * 4;
                    const xB = Math.min(Math.max(x - rgbOffset + totalShift, 0), originalWidth - 1);
                    const iB = (y * originalWidth + xB) * 4;

                    fullGlitchData.data[i] = fullOriginalData.data[iR];
                    fullGlitchData.data[i + 1] = fullOriginalData.data[iG + 1];
                    fullGlitchData.data[i + 2] = fullOriginalData.data[iB + 2];

                    if (blockShift !== 0) {
                        if (blockType < 0.3) {
                            fullGlitchData.data[i] = 255 - fullGlitchData.data[i];
                            fullGlitchData.data[i + 1] = 255 - fullGlitchData.data[i + 1];
                            fullGlitchData.data[i + 2] = 255 - fullGlitchData.data[i + 2];
                        } else if (blockType < 0.5) {
                            fullGlitchData.data[i] = Math.min(fullGlitchData.data[i] * 1.5, 255);
                        } else if (blockType < 0.7) {
                            fullGlitchData.data[i + 1] = Math.min(fullGlitchData.data[i + 1] * 1.3, 255);
                            fullGlitchData.data[i + 2] = Math.min(fullGlitchData.data[i + 2] * 1.3, 255);
                        }
                    }

                    if (randomGlitch && Math.random() < 0.1) {
                        const noise = Math.floor((Math.random() - 0.5) * 100);
                        fullGlitchData.data[i] = Math.max(0, Math.min(255, fullGlitchData.data[i] + noise));
                        fullGlitchData.data[i + 1] = Math.max(0, Math.min(255, fullGlitchData.data[i + 1] + noise));
                        fullGlitchData.data[i + 2] = Math.max(0, Math.min(255, fullGlitchData.data[i + 2] + noise));
                    }
                }
            }

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            const numStripes = Math.floor(scaledGlitchIntensity / 8);
            for (let i = 0; i < numStripes; i++) {
                const stripeX = Math.floor(Math.random() * originalWidth);
                const stripeWidth = Math.floor(Math.random() * 5) + 1;
                const stripeShift = Math.floor((Math.random() - 0.5) * scaledGlitchIntensity);

                for (let y = 0; y < originalHeight; y++) {
                    for (let dx = 0; dx < stripeWidth; dx++) {
                        const x = stripeX + dx;
                        if (x >= 0 && x < originalWidth) {
                            const sourceY = Math.min(Math.max(y + stripeShift, 0), originalHeight - 1);
                            const i = (y * originalWidth + x) * 4;
                            const iSource = (sourceY * originalWidth + x) * 4;

                            fullGlitchData.data[i] = fullOriginalData.data[iSource];
                            fullGlitchData.data[i + 1] = fullOriginalData.data[iSource + 1];
                            fullGlitchData.data[i + 2] = fullOriginalData.data[iSource + 2];
                        }
                    }
                }
            }

            // –ù–∞—á–∏–Ω–∞–µ–º —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–∞
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            exportCanvas.width = originalWidth;
            exportCanvas.height = originalHeight;
            exportCtx.drawImage(currentImage, 0, 0, originalWidth, originalHeight);

            let result = exportCtx.getImageData(0, 0, originalWidth, originalHeight);

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö —Å–æ–∑–¥–∞–Ω–∏—è
            operations.forEach(operation => {
                // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –º–∞—Å–∫—É –æ–ø–µ—Ä–∞—Ü–∏–∏
                const scaledMaskCanvas = document.createElement('canvas');
                const scaledMaskCtx = scaledMaskCanvas.getContext('2d');
                scaledMaskCanvas.width = originalWidth;
                scaledMaskCanvas.height = originalHeight;
                scaledMaskCtx.imageSmoothingEnabled = true;
                scaledMaskCtx.drawImage(operation.maskCanvas, 0, 0, canvas.width, canvas.height, 0, 0, originalWidth, originalHeight);

                const maskData = scaledMaskCtx.getImageData(0, 0, originalWidth, originalHeight).data;

                let effectData;
                if (operation.type === 'pixelate') {
                    effectData = fullPixelatedData;
                } else if (operation.type === 'blur') {
                    effectData = fullBlurredData;
                } else if (operation.type === 'glitch') {
                    effectData = fullGlitchData;
                }

                for (let i = 0; i < result.data.length; i += 4) {
                    const maskValue = maskData[i] / 255;
                    result.data[i] = result.data[i] * (1 - maskValue) + effectData.data[i] * maskValue;
                    result.data[i + 1] = result.data[i + 1] * (1 - maskValue) + effectData.data[i + 1] * maskValue;
                    result.data[i + 2] = result.data[i + 2] * (1 - maskValue) + effectData.data[i + 2] * maskValue;
                }
            });

            exportCtx.putImageData(result, 0, 0);

            // –°–∫–∞—á–∏–≤–∞–µ–º
            const link = document.createElement('a');
            link.download = 'jackalizer-result.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        });

        // –°–±—Ä–æ—Å
        resetBtn.addEventListener('click', () => {
            currentImage = null;
            originalImageData = null;
            pixelatedImageData = null;
            blurredImageData = null;
            glitchImageData = null;
            operations = [];
            lastDrawnEffect = null;
            currentEffect = 'pixelate';
            fileInput.value = '';
            pixelSizeSlider.value = 62;
            pixelSizeValue.textContent = '62';
            blurSizeSlider.value = 10;
            blurSizeValue.textContent = '10';
            glitchIntensitySlider.value = 15;
            glitchIntensityValue.textContent = '15';
            brushSize = 30;
            brushSizeValue.textContent = '30';
            brushMode = 'brush';
            brushBtn.classList.remove('active');
            eraserBtn.classList.remove('active');
            pixelEffectBtn.classList.add('active');
            blurEffectBtn.classList.remove('active');
            glitchEffectBtn.classList.remove('active');
            pixelControls.classList.remove('hidden');
            blurControls.classList.add('hidden');
            glitchControls.classList.add('hidden');
            dropZone.classList.remove('hidden');
            canvas.style.display = 'none';
            rightPanel.classList.add('hidden');
            mainContainer.classList.remove('two-panels');
            brushControls.classList.add('hidden');
            buttons.classList.add('hidden');
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∂–∏–º–∞ –∫–∏—Å—Ç–∏
        brushBtn.classList.add('active');
    </script>
</body>
</html>